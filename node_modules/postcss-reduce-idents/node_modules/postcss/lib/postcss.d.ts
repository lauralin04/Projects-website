/**
 * @param plugins Can also be included with the Processor#use method.
 * @returns A processor that will apply plugins as CSS processors.
 */
declare function postcss(plugins?: postcss.AcceptedPlugin[]): postcss.Processor;
declare function postcss(...plugins: postcss.AcceptedPlugin[]): postcss.Processor;
declare namespace postcss {
    type AcceptedPlugin = Plugin<any> | Transformer | {
        postcss: TransformCallback | Processor;
    } | Processor;
    /**
     * Creates a PostCSS plugin with a standard API.
     * @param name Plugin name. Same as in name property in package.json. It will
     * be saved in plugin.postcssPlugin property.
     * @param initializer Will receive plugin options and should return functions
     * to modify nodes in input CSS.
     */
    function plugin<T>(name: string, initializer: PluginInitializer<T>): Plugin<T>;
    interface Plugin<T> extends Transformer {
        (opts?: T): Transformer;
        postcss: Transformer;
        process: (css: string | {
            toString(): string;
        } | Result, opts?: any) => LazyResult;
    }
    interface Transformer extends TransformCallback {
        postcssPlugin?: string;
        postcssVersion?: string;
    }
    interface TransformCallback {
        /**
         * @returns Asynchronous plugins should return a promise.
         */
        (root: Root, result?: Result): void | Function | any;
    }
    interface PluginInitializer<T> {
        (pluginOptions?: T): Transformer;
    }
    /**
     * Contains helpers for working with vendor prefixes.
     */
    export namespace vendor {
        /**
         * @returns The vendor prefix extracted from the input string.
         */
        function prefix(prop: string): string;
        /**
         * @returns The input string stripped of its vendor prefix.
         */
        function unprefixed(prop: string): string;
    }
    export class Stringifier {
        builder: Stringifier.Builder;
        constructor(builder?: Stringifier.Builder);
        stringify(node: Node, semicolon?: boolean): void;
        root(node: any): void;
        comment(node: any): void;
        decl(node: any, semicolon: any): void;
        rule(node: any): void;
        atrule(node: any, semicolon: any): void;
        body(node: any): void;
        block(node: any, start: any): void;
        raw(node: Node, own: string, detect?: string): any;
        rawSemicolon(root: any): any;
        rawEmptyBody(root: any): any;
        rawIndent(root: any): any;
        rawBeforeComment(root: any, node: any): any;
        rawBeforeDecl(root: any, node: any): any;
        rawBeforeRule(root: any): any;
        rawBeforeClose(root: any): any;
        rawBeforeOpen(root: any): any;
        rawColon(root: any): any;
        beforeAfter(node: any, detect: any): any;
        rawValue(node: any, prop: any): any;
    }
    export namespace Stringifier {
        interface Builder {
            (str: string, node?: Node, str2?: string): void;
        }
    }
    /**
     * Default function to convert a node tree into a CSS string.
     */
    function stringify(node: Node, builder: Stringifier.Builder): void;
    /**
     * Parses source CSS.
     * @param css The CSS to parse.
     * @param options
     * @returns {} A new Root node, which contains the source CSS nodes.
     */
    function parse(css: string | {
        toString(): string;
    } | LazyResult | Result, options?: {
        from?: string;
        map?: postcss.SourceMapOptions;
    }): Root;
    /**
     * Contains helpers for safely splitting lists of CSS values, preserving
     * parentheses and quotes.
     */
    export namespace list {
        /**
         * Safely splits space-separated values (such as those for background,
         * border-radius and other shorthand properties).
         */
        function space(str: string): string[];
        /**
         * Safely splits comma-separated values (such as those for transition-* and
         * background  properties).
         */
        function comma(str: string): string[];
    }
    /**
     * Creates a new Comment node.
     * @param defaults Properties for the new Comment node.
     * @returns The new node.
     */
    function comment(defaults?: CommentNewProps): Comment;
    /**
     * Creates a new AtRule node.
     * @param defaults Properties for the new AtRule node.
     * @returns The new node.
     */
    function atRule(defaults?: AtRuleNewProps): AtRule;
    /**
     * Creates a new Declaration node.
     * @param defaults Properties for the new Declaration node.
     * @returns The new node.
     */
    function decl(defaults?: DeclarationNewProps): Declaration;
    /**
     * Creates a new Rule node.
     * @param defaults Properties for the new Rule node.
     * @returns The new node.
     */
    function rule(defaults?: RuleNewProps): Rule;
    /**
     * Creates a new Root node.
     * @param defaults Properties for the new Root node.
     * @returns The new node.
     */
    function root(defaults?: Object): Root;
    interface SourceMapOptions {
        /**
         * Indicates that the source map should be embedded in the output CSS as a
         * Base64-encoded comment. By default, it is true. But if all previous maps
         * are external, not inline, PostCSS will not embed the map even if you do
         * not set this option.
         *
         * If you have an inline source map, the result.map property will be empty,
         * as the source map will be contained within the text of result.css.
         */
        inline?: boolean;
        /**
         * Source map content from a previous processing step (e.g., Sass compilation).
         * PostCSS will try to read the previous source map automatically (based on comments
         * within the source CSS), but you can use this option to identify it manually.
         * If desired, you can omit the previous map with prev: false.
         */
        prev?: any;
        /**
         * Indicates that PostCSS should set the origin content (e.g., Sass source)
         * of the source map. By default, it is true. But if all previous maps do not
         * contain sources content, PostCSS will also leave it out even if you do not set
         * this option.
         */
        sourcesContent?: boolean;
        /**
         * Indicates that PostCSS should add annotation comments to the CSS. By default,
         * PostCSS will always add a comment with a path to the source map. PostCSS will
         * not add annotations to CSS files that do not contain any comments.
         *
         * By default, PostCSS presumes that you want to save the source map as
         * opts.to + '.map' and will use this path in the annotation comment. A different
         * path can be set by providing a string value for annotation.
         *
         * If you have set inline: true, annotation cannot be disabled.
         */
        annotation?: boolean | string;
        /**
         * If true, PostCSS will try to correct any syntax errors that it finds in the CSS.
         * This is useful for legacy code filled with hacks. Another use-case is interactive
         * tools with live input â€” for example, the Autoprefixer demo.
         */
        safe?: boolean;
    }
    /**
     * A Processor instance contains plugins to process CSS. Create one
     * Processor  instance, initialize its plugins, and then use that instance
     * on numerous CSS files.
     */
    interface Processor {
        /**
         * Adds a plugin to be used as a CSS processor. Plugins can also be
         * added by passing them as arguments when creating a postcss instance.
         */
        use(plugin: AcceptedPlugin): Processor;
        /**
         * Parses source CSS. Because some plugins can be asynchronous it doesn't
         * make any transformations. Transformations will be applied in LazyResult's
         * methods.
         * @param css Input CSS or any object with toString() method, like a file
         * stream. If a Result instance is passed the processor will take the
         * existing Root parser from it.
         */
        process(css: string | {
            toString(): string;
        } | Result, options?: ProcessOptions): LazyResult;
        /**
         * Contains plugins added to this processor.
         */
        plugins: Plugin<any>[];
        /**
         * Contains the current version of PostCSS (e.g., "4.0.5").
         */
        version: string;
    }
    interface ProcessOptions extends Syntax {
        /**
         * The path of the CSS source file. You should always set from, because it is
         * used in source map generation and syntax error 